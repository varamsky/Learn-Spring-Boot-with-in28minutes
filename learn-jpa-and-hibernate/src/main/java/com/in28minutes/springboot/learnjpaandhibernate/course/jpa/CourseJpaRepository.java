package com.in28minutes.springboot.learnjpaandhibernate.course.jpa;

import com.in28minutes.springboot.learnjpaandhibernate.course.Course;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import jakarta.transaction.Transactional;
import org.springframework.stereotype.Repository;

/*
 * @Repository means that this class will talk to the database
 */
@Repository
// @Transactional is needed when using JPA.
// A JPA Transaction is needed for all your methods - essentially a transaction is what opens a Hibernate session, and you need an open session to interact with it.
// However, it is needed only for cases when you make a change to the database with add, update or delete.
// If you only want to read from the database you can omit @Transactional annotation.
// For testing this, comment out the insert deleteById method usage in the CourseCommandLineRunner run() and you would be able to use this call without the @Transactional annotation.
@Transactional
public class CourseJpaRepository {
    @PersistenceContext
    // we could also use @Autowired here, but @PersistenceContext is specifically used for auto-wiring EntityManager
    private EntityManager entityManager;

    public void insert(Course course) {
        entityManager.merge(course);
//        entityManager.persist(course);

        /*
        There are 2 methods merge() and persist() which we can use here.
        I wondered what is the difference.
        Also, when using merge enable jpa to show-sql in the application.properties as this will show the SQL that is generated by JPA in the background.
        You will notice that every time the merge() is called it does a SELECT statement and then an INSERT statement.
        This can be a problematic overhead when working with large amount of data.
        But it has an up-side.

        "The Hibernate does not trigger a select query for update method. It is the merge that triggers an extra select to avoid duplicate record error(NonUniqueObjectException)."
         So the SELECT before every INSERT in the case of merge checks for duplicate values being entered(especially in the case of ID or Primary Key which can lead to errors)

         So, if you try to add duplicate values with merge() it handles it without any exception however, using persist() leads to an Exception.

         However, using persist() also has an advantage. See https://stackoverflow.com/questions/1069992/jpa-entitymanager-why-use-persist-over-merge#:~:text=Persist%20takes%20an%20entity%20instance,new%20instance%20of%20your%20entity
         */
    }

    public Course findById(long id) {
        return entityManager.find(Course.class, id);
    }

    public void deleteById(long id) {
        Course course = entityManager.find(Course.class, id);
        entityManager.remove(course);
    }
}
